// solver関数の第一引数に二次元配列を渡します。
// 未定の部分は「0」としてください。
// solver関数では引数として受け取った配列そのものを変更します。
// solver関数は解くことができたら「true」を、失敗したら「false」を返します。

const solver = (array_9x9, x=0, y=0) => {
	if (numberCount - 1 < y) {
		return true
	} else if (array_9x9[y][x] !== 0) {
		if (x === numberCount - 1) {
			if (solver(array_9x9, 0, y + 1)) {
				return true;
			}
		} else {
			if (solver(array_9x9, x + 1, y)) {
				return true;
			}
		}
	} else {
		for (let i = 1; i <= 9; i++) {
			if (check(array_9x9, [x, y], i)) {
				array_9x9[y][x] = i;
				if (x === numberCount - 1) {
					if (solver(array_9x9, 0, y + 1)) {
						return true;
					}
				} else {
					if (solver(array_9x9, x + 1, y)) {
						return true;
					}
				}
			}
		}
		array_9x9[y][x] = 0;
		return false;
	}
}


const check = (array_9x9, [x, y], i) => {
	if (row(array_9x9, y, i) && column(array_9x9, x, i) && block(array_9x9, [x, y], i)) {
		return true;
	}
	return false;
}

const row = (array_9x9, y, i) => {
	let answer = true;
	for (let X = 0; X < numberCount; X++) {
		if (array_9x9[y][X] === i) {
			answer = false;
		}
	}
	return answer;
}
const column = (array_9x9, x, i) => {
	let answer = true;
	for (let Y = 0; Y < numberCount; Y++) {
		if (array_9x9[Y][x] === i) {
			answer = false;
		}
	}
	return answer;
}
const block = (array_9x9, [x, y], i) => {
	let answer = true;
	const
		xBase = Math.floor(x / 3) * 3,
		yBase = Math.floor(y / 3) * 3
	;
	for (let X = xBase; X < xBase + 3; X++) {
		for (let Y = yBase; Y < yBase + 3; Y++) {
			if (array_9x9[Y][X] === i) {
				answer = false;
			}
		}
	}
	return answer
}
